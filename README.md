# triangle-area
calculates triangle area

Непонятно много чего:
  * какие требования по точности? Для конкретных операций из формулы можно вычислить ожидаемую относительную погрешность операции. Я этого, конечно, делать не стал :) Ну и, соответственно, в зависимости от требуемой точности выбирать вообще нужные типы. Или даже сделать метод полиморфным по входным аргументам. Но, по-моему, это решение - не очень, т.к. вариантов не так много и лучше явно для каждого типа сделать перегрузку метода, в некоторых случаях повышая точность вычисления (например, для входных float'ов, считая промежуток в double), либо жертвовать возможностью повысить точность в угоду производительности.

  * кто ответственен за случаи, когда в результате вычисления ответ double.PositiveInfinity? В своем решении ответственность на вызывающем коде

  * т.к. не совсем понятно, что с точностью (ну и, частично, потому, что руками вычислять много тестовых примеров было слегка лень), набор тестов со сравнением "нормальных" результатов очень мал. В общем можно было побольше

  * тесты стоило разбить на большее количество. Например, выделить те, что проверяют симметричность по аргументам отдельно. Также я явно проверяю метод проверки существования треугольника. Возможный вариант - его скрыть (сделать приватным), а проверку на исключения делать для оригинального метода GetArea
